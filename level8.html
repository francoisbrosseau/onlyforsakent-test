<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ONLYFORSAKEN — Level 8</title>

  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Cormorant+Garamond:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      /* ===== Cinematic framing controls (non-stretched cover) ===== */
      --bg-zoom-mobile: 1.06;
      --bg-pos-mobile: 50% 50%;

      --bg-zoom-desktop: 1.00;
      --bg-pos-desktop: 50% 50%;

      /* ===== Colors ===== */
      --text: rgba(255,255,255,0.90);
      --muted: rgba(255,255,255,0.55);
      --shadow: rgba(0,0,0,0.70);

      --seal-bg: rgba(10,10,10,0.55);
      --seal-border: rgba(255,255,255,0.10);
      --seal-border-strong: rgba(255,255,255,0.18);

      /* Fog pacing contract */
      --MIN_TOTAL: 74;     /* seconds */
      --MIN_LINE_DUR: 5.8; /* seconds */
      --MIN_GAP: 1.15;     /* seconds */
      --START_DELAY: 1.35; /* seconds */
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:#000; color:var(--text); }
    body{
      font-family:"Cormorant Garamond", Georgia, "Times New Roman", serif;
      overflow-x:hidden;
    }

    /* ===== Fixed cinematic background ===== */
    .bg{
      position:fixed; inset:0; z-index:-3;
      background:#000;
      overflow:hidden;
    }
    .bg::before{
      content:"";
      position:absolute; inset:-2%;
      background-image: var(--bg-url);
      background-size: cover;
      background-repeat:no-repeat;
      background-position: var(--bg-pos-mobile);
      transform: scale(var(--bg-zoom-mobile));
      filter: saturate(0.95) contrast(1.02);
      opacity:0;
      transition: opacity 1100ms ease;
      will-change: transform, opacity;
    }
    @media (min-width: 860px){
      .bg::before{
        background-position: var(--bg-pos-desktop);
        transform: scale(var(--bg-zoom-desktop));
      }
    }

    /* Veil fade + grain */
    .veil{
      position:fixed; inset:0; z-index:-2;
      background:#000;
      opacity:1;
      transition: opacity 900ms ease;
      pointer-events:none;
    }
    .grain{
      position:fixed; inset:0; z-index:-1;
      pointer-events:none;
      opacity:0.14;
      background-image:
        radial-gradient(circle at 20% 10%, rgba(255,255,255,0.06), transparent 40%),
        radial-gradient(circle at 80% 30%, rgba(255,255,255,0.05), transparent 45%),
        radial-gradient(circle at 30% 80%, rgba(255,255,255,0.04), transparent 50%);
      mix-blend-mode: overlay;
      filter: contrast(1.1);
    }

    /* ===== Page wrap ===== */
    .wrap{
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding: clamp(18px, 3vw, 34px);
    }
    .panel{
      width:min(920px, 100%);
      margin-top: clamp(18px, 4vh, 54px);
      position:relative;
    }

    /* Title */
    h1{
      font-family:"Cinzel Decorative", serif;
      font-weight:700;
      letter-spacing:0.06em;
      text-transform:uppercase;
      margin:0 0 12px 0;
      font-size: clamp(22px, 3.2vw, 34px);
      text-shadow: 0 14px 38px var(--shadow);
    }
    .sub{
      margin:0 0 18px 0;
      color:var(--muted);
      letter-spacing:0.04em;
      text-shadow: 0 10px 28px var(--shadow);
      font-size: clamp(14px, 2vw, 16px);
    }

    /* Story */
    .story{
      font-size: clamp(20px, 2.2vw, 24px);
      letter-spacing: 0.04em;
      line-height: 1.75;
      text-shadow: 0 14px 42px var(--shadow);
      padding-bottom: 22px;
    }

    /* Fog reveal lines */
    .fogLine{
      position:relative;
      display:block;
      margin: 0 0 14px 0;
      padding: 2px 0;
    }
    .fogLine .fogMask{
      display:inline;
      filter: blur(7px);
      opacity:0.15;
      clip-path: inset(0 100% 0 0);
      transition: clip-path 1200ms linear, filter 1200ms ease, opacity 1200ms ease;
    }
    .fogLine.revealed .fogMask{
      clip-path: inset(0 0 0 0);
      filter: blur(0px);
      opacity:1;
    }

    /* Puzzle HUD */
    .puzzleHint{
      margin: 10px 0 14px 0;
      color: rgba(255,255,255,0.72);
      letter-spacing:0.04em;
      text-shadow: 0 10px 28px var(--shadow);
      font-size: clamp(14px, 2vw, 16px);
    }
    .glyphRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin: 0 0 14px 0;
    }
    .glyph{
      width: 34px; height: 34px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.25);
      box-shadow: 0 14px 34px rgba(0,0,0,0.5);
      display:flex; align-items:center; justify-content:center;
      font-family:"Cinzel Decorative", serif;
      font-weight:700;
      letter-spacing:0.06em;
      color: rgba(255,255,255,0.85);
      user-select:none;
    }
    .glyph.dim{
      color: rgba(255,255,255,0.25);
      border-color: rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
    }
    .glyph.pop{
      animation: pop 260ms ease-out;
    }
    @keyframes pop{
      from{ transform: scale(0.92); }
      to{ transform: scale(1); }
    }

    /* Invisible clickable sigil hotspots */
    .hotspots{
      position:fixed; inset:0;
      z-index:2;
      pointer-events:none; /* enabled after first user gesture */
    }
    .hotspot{
      position:absolute;
      width: 56px; height: 56px;
      border-radius: 999px;
      pointer-events:auto;
      background: rgba(255,255,255,0.00);
      border: 1px solid rgba(255,255,255,0.00);
      outline: none;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .hotspot:active{ transform: scale(0.98); }

    /* ===== Antique seal gate ===== */
    .seal{
      margin-top: 18px;
      padding: 14px 14px 12px 14px;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(0,0,0,0.38), rgba(0,0,0,0.18));
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 22px 60px rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
    }
    .sealLabel{
      font-family:"Cinzel Decorative", serif;
      letter-spacing:0.08em;
      color: rgba(255,255,255,0.80);
      font-size: 12px;
      margin: 0 0 10px 4px;
      text-transform: uppercase;
    }
    .sealRow{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .sealInput{
      flex:1;
      padding: 14px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.40);
      color: rgba(255,255,255,0.92);
      font-size: 16px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      outline:none;
    }
    .sealInput::placeholder{
      color: rgba(255,255,255,0.25);
      letter-spacing:0.12em;
      text-transform:none;
    }
    .sealBtn{
      padding: 14px 16px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(20,20,20,0.55);
      color: rgba(255,255,255,0.90);
      font-family:"Cinzel Decorative", serif;
      letter-spacing:0.10em;
      cursor:pointer;
      user-select:none;
      text-transform: uppercase;
      min-width: 124px;
    }
    .sealBtn:hover{ border-color: rgba(255,255,255,0.28); }
    .sealBtn:active{ transform: translateY(1px); }

    .shake{ animation: shake 420ms ease; }
    @keyframes shake{
      0%,100%{ transform: translateX(0); }
      20%{ transform: translateX(-6px); }
      40%{ transform: translateX(6px); }
      60%{ transform: translateX(-4px); }
      80%{ transform: translateX(4px); }
    }

    /* ===== Single mute button ===== */
    .muteBtn{
      position: fixed;
      top: 14px;
      right: 14px;
      z-index: 5;
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.42);
      color: rgba(255,255,255,0.86);
      font-family: "Cinzel Decorative", serif;
      letter-spacing:0.08em;
      text-transform:uppercase;
      cursor:pointer;
      backdrop-filter: blur(6px);
      box-shadow: 0 18px 50px rgba(0,0,0,0.55);
    }

    /* ===== Inventory (3 slots) ===== */
    .inv{
      position: fixed;
      left: 14px;
      top: 14px;
      z-index: 5;
      display:flex;
      gap: 8px;
      align-items:center;
      padding: 10px 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.38);
      backdrop-filter: blur(6px);
      box-shadow: 0 18px 50px rgba(0,0,0,0.55);
    }
    .slot{
      width: 38px; height: 38px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.26);
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
    }
    .slot img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.95;
    }
    .slot .dash{
      color: rgba(255,255,255,0.30);
      font-size: 18px;
      line-height: 1;
      user-select:none;
    }

    /* Fade-out on success */
    .fadeOut{ animation: fadeOut 850ms ease forwards; }
    @keyframes fadeOut{ to{ opacity:0; filter: blur(2px); } }

    @media (max-width: 520px){
      .sealRow{ flex-direction: column; align-items: stretch; }
      .sealBtn{ width:100%; }
      .panel{ margin-top: 18px; }
    }
  </style>
</head>

<body>
  <div class="bg" id="bg"></div>
  <div class="veil" id="veil"></div>
  <div class="grain"></div>

  <div class="inv" id="inv" aria-label="Inventory">
    <div class="slot" id="slot0"><div class="dash">—</div></div>
    <div class="slot" id="slot1"><div class="dash">—</div></div>
    <div class="slot" id="slot2"><div class="dash">—</div></div>
  </div>

  <button class="muteBtn" id="muteBtn" type="button">MUTE</button>

  <!-- Invisible hotspots (positions are % so they scale with your image perfectly) -->
  <div class="hotspots" id="hotspots" aria-hidden="true">
    <button class="hotspot" data-key="S" style="left:12%; top:64%;" aria-label="sigil"></button>
    <button class="hotspot" data-key="E" style="left:71%; top:22%;" aria-label="sigil"></button>
    <button class="hotspot" data-key="A" style="left:43%; top:48%;" aria-label="sigil"></button>
    <button class="hotspot" data-key="L" style="left:82%; top:69%;" aria-label="sigil"></button>
    <button class="hotspot" data-key="8" style="left:26%; top:18%;" aria-label="sigil"></button>
  </div>

  <div class="wrap" id="page">
    <div class="panel">
      <h1>Level VIII — The Unseen Marks</h1>
      <p class="sub">The corridor tightens. The air feels older than stone.</p>

      <div class="story" id="story">
        <span class="fogLine"><span class="fogMask">You step into a hall where the walls do not reflect light—only swallow it.</span></span>
        <span class="fogLine"><span class="fogMask">Somewhere beneath the plaster, something has been scratched over and over, as if a prisoner tried to write with bone.</span></span>
        <span class="fogLine"><span class="fogMask">The floor is dry, yet your boots leave prints as if the dust itself remembers you.</span></span>
        <span class="fogLine"><span class="fogMask">A seal waits at the far end—antique, patient, and hungry for a word you cannot see.</span></span>

        <p class="puzzleHint">The image hides five marks. Touch them and the word will assemble.</p>

        <div class="glyphRow" id="glyphRow" aria-label="Revealed letters">
          <div class="glyph dim" id="g0">—</div>
          <div class="glyph dim" id="g1">—</div>
          <div class="glyph dim" id="g2">—</div>
          <div class="glyph dim" id="g3">—</div>
          <div class="glyph dim" id="g4">—</div>
        </div>

        <span class="fogLine"><span class="fogMask">When you blink, you swear the darkness shifts—just enough to point you where it wants you to look.</span></span>
      </div>

      <div class="seal" id="seal">
        <div class="sealLabel">Carved Seal</div>
        <div class="sealRow">
          <input class="sealInput" id="pass" type="text" inputmode="text" autocomplete="off" spellcheck="false" placeholder="Enter the word…" />
          <button class="sealBtn" id="unseal" type="button">UNSEAL</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * LOCKED PATH RULE: same folder as this HTML
     ***********************/
    const BG_IMAGE = "level8.jpg";   // <-- SAME folder as this HTML file
    const NEXT_PAGE = "level9.html";

    // Puzzle required sequence (5 steps)
    const REQUIRED_SEQUENCE = ["S","E","A","L","8"];

    // Optional audio (same-folder or your existing convention; leave blank if none)
    const VOICE_SRC = "";  // e.g. "level8-voice.mp3"
    const AMBI_SRC  = "";  // e.g. "level8-amb.mp3"
    const VOICE_VOL = 0.74;
    const AMBI_VOL  = 0.30;

    /***********************
     * Background setup
     ***********************/
    document.documentElement.style.setProperty("--bg-url", `url('${BG_IMAGE}')`);
    const veil = document.getElementById("veil");
    setTimeout(() => { veil.style.opacity = "0"; }, 260);

    const style = document.createElement("style");
    style.textContent = `body[data-ready="1"] .bg::before{ opacity:1; }`;
    document.head.appendChild(style);
    requestAnimationFrame(()=>{ document.body.dataset.ready = "1"; });

    /***********************
     * Inventory (persistent; hidden until reveal gate)
     ***********************/
    const INV_KEY = "ofs_inventory";
    const INV_REVEAL_KEY = "ofs_inv_reveal_level";

    function normalizeInventory(raw){
      const empty = [null,null,null];
      if (!raw) return empty;

      let inv = null;
      try{ inv = JSON.parse(raw); }catch(e){ inv = null; }

      if (Array.isArray(inv)){
        return inv.slice(0,3).concat([null,null,null]).slice(0,3).map(x=>{
          if (!x) return null;
          if (typeof x === "string") return { id:x, img:"", alt:x };
          if (typeof x === "object" && x.id) return { id:x.id, img:x.img||"", alt:x.alt||x.id };
          return null;
        });
      }
      return empty;
    }

    function renderInventory(){
      const revealAt = parseInt(localStorage.getItem(INV_REVEAL_KEY) || "0", 10);
      const hidden = (revealAt < 7);

      const inv = normalizeInventory(localStorage.getItem(INV_KEY));
      for (let i=0;i<3;i++){
        const slot = document.getElementById("slot"+i);
        slot.innerHTML = "";
        if (hidden || !inv[i]){
          const d = document.createElement("div");
          d.className = "dash";
          d.textContent = "—";
          slot.appendChild(d);
        }else{
          const item = inv[i];
          if (item.img){
            const im = document.createElement("img");
            im.src = item.img;
            im.alt = item.alt || item.id;
            slot.appendChild(im);
          }else{
            const d = document.createElement("div");
            d.className = "dash";
            d.textContent = "•";
            slot.appendChild(d);
          }
        }
      }
    }
    renderInventory();

    /***********************
     * Fog reveal pacing (contract)
     ***********************/
    const lines = Array.from(document.querySelectorAll(".fogLine"));
    function runFogReveal(totalTargetSeconds){
      const cs = getComputedStyle(document.documentElement);
      const MIN_TOTAL = parseFloat(cs.getPropertyValue("--MIN_TOTAL")) || 74;
      const MIN_LINE_DUR = parseFloat(cs.getPropertyValue("--MIN_LINE_DUR")) || 5.8;
      const MIN_GAP = parseFloat(cs.getPropertyValue("--MIN_GAP")) || 1.15;
      const START_DELAY = parseFloat(cs.getPropertyValue("--START_DELAY")) || 1.35;

      const n = Math.max(1, lines.length);
      const target = Math.max(MIN_TOTAL, totalTargetSeconds || 0);

      const base = (n * MIN_LINE_DUR) + ((n-1) * MIN_GAP) + START_DELAY;
      const extra = Math.max(0, target - base);
      const extraPerLine = extra / n;

      let t = START_DELAY;
      lines.forEach((ln, idx)=>{
        const dur = MIN_LINE_DUR + extraPerLine;
        setTimeout(()=> ln.classList.add("revealed"), t*1000);
        t += dur;
        if (idx !== n-1) t += MIN_GAP;
      });
    }

    /***********************
     * Audio (single mute/unmute; persistent)
     ***********************/
    const MUTE_KEY = "ofs_mute";
    const muteBtn = document.getElementById("muteBtn");

    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const ctx = AudioCtx ? new AudioCtx() : null;

    let voiceEl = null, ambEl = null;
    let voiceGain = null, ambGain = null;

    function isMuted(){ return localStorage.getItem(MUTE_KEY) === "1"; }
    function setMuted(v){
      localStorage.setItem(MUTE_KEY, v ? "1" : "0");
      updateMuteUI();
      applyMuteState();
    }
    function updateMuteUI(){
      muteBtn.textContent = isMuted() ? "UNMUTE" : "MUTE";
    }
    updateMuteUI();

    function setupAudio(){
      if (!ctx) return;

      if (VOICE_SRC){
        voiceEl = new Audio();
        voiceEl.src = VOICE_SRC;
        voiceEl.preload = "auto";
        voiceEl.crossOrigin = "anonymous";
      }
      if (AMBI_SRC){
        ambEl = new Audio();
        ambEl.src = AMBI_SRC;
        ambEl.preload = "auto";
        ambEl.loop = true;
        ambEl.crossOrigin = "anonymous";
      }
      if (!(voiceEl || ambEl)) return;

      if (voiceEl){
        const src = ctx.createMediaElementSource(voiceEl);
        voiceGain = ctx.createGain();
        voiceGain.gain.value = 0.0001;
        src.connect(voiceGain).connect(ctx.destination);
      }
      if (ambEl){
        const src = ctx.createMediaElementSource(ambEl);
        ambGain = ctx.createGain();
        ambGain.gain.value = 0.0001;
        src.connect(ambGain).connect(ctx.destination);
      }
      applyMuteState(true);
    }

    function applyMuteState(initial=false){
      const muted = isMuted();
      const now = ctx ? ctx.currentTime : 0;
      const fadeFast = 0.22;
      const fadeSoft = 0.55;

      if (voiceGain){
        voiceGain.gain.cancelScheduledValues(now);
        voiceGain.gain.setValueAtTime(voiceGain.gain.value, now);
        voiceGain.gain.linearRampToValueAtTime(muted ? 0.0001 : VOICE_VOL, now + (initial ? 0.001 : fadeFast));
      }
      if (ambGain){
        ambGain.gain.cancelScheduledValues(now);
        ambGain.gain.setValueAtTime(ambGain.gain.value, now);
        ambGain.gain.linearRampToValueAtTime(muted ? 0.0001 : AMBI_VOL, now + (initial ? 0.001 : fadeSoft));
      }

      if (muted){
        if (voiceEl) voiceEl.pause();
        if (ambEl) ambEl.pause();
      }
    }

    function startAudioIfAllowed(){
      if (isMuted()) return;
      if (voiceEl){
        try{ voiceEl.currentTime = 0; }catch(e){}
        voiceEl.play().catch(()=>{});
      }
      if (ambEl){
        ambEl.play().catch(()=>{});
      }
    }

    muteBtn.addEventListener("click", ()=>{
      setMuted(!isMuted());
      if (!isMuted()) startAudioIfAllowed();
    });

    setupAudio();

    // Autoplay unlock on first gesture + enable hotspots
    let unlocked = false;
    function unlockOnce(){
      if (unlocked) return;
      unlocked = true;

      document.getElementById("hotspots").style.pointerEvents = "auto";

      if (ctx && ctx.state !== "running"){
        ctx.resume().catch(()=>{});
      }
      startAudioIfAllowed();
    }
    window.addEventListener("pointerdown", unlockOnce, {passive:true, once:true});

    // pageshow restart
    window.addEventListener("pageshow", (e)=>{
      if (e.persisted){
        if (voiceEl) { try{ voiceEl.pause(); voiceEl.currentTime = 0; }catch(_){} }
        if (ambEl) { try{ ambEl.pause(); ambEl.currentTime = 0; }catch(_){} }
        lines.forEach(l=> l.classList.remove("revealed"));
        runFogReveal(0);
        unlocked = false;
        window.addEventListener("pointerdown", unlockOnce, {passive:true, once:true});
      }
    });

    /***********************
     * Puzzle
     ***********************/
    const glyphEls = [
      document.getElementById("g0"),
      document.getElementById("g1"),
      document.getElementById("g2"),
      document.getElementById("g3"),
      document.getElementById("g4"),
    ];
    let progress = 0;

    function resetProgress(){
      progress = 0;
      for (let i=0;i<glyphEls.length;i++){
        glyphEls[i].textContent = "—";
        glyphEls[i].classList.add("dim");
        glyphEls[i].classList.remove("pop");
      }
      document.querySelectorAll(".hotspot").forEach(b=>{
        b.disabled = false;
        b.style.pointerEvents = "auto";
      });
    }

    function revealStep(ch){
      const el = glyphEls[progress];
      el.textContent = ch;
      el.classList.remove("dim");
      el.classList.remove("pop");
      void el.offsetWidth;
      el.classList.add("pop");
    }

    function completeWord(){
      document.getElementById("pass").value = REQUIRED_SEQUENCE.join("");
    }

    resetProgress();

    document.querySelectorAll(".hotspot").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const key = btn.getAttribute("data-key");
        const required = REQUIRED_SEQUENCE[progress];

        if (key === required){
          revealStep(key);
          progress++;
          btn.disabled = true;
          btn.style.pointerEvents = "none";
          if (progress >= REQUIRED_SEQUENCE.length) completeWord();
        }else{
          const seal = document.getElementById("seal");
          seal.classList.remove("shake");
          void seal.offsetWidth;
          seal.classList.add("shake");
          resetProgress();
        }
      });
    });

    /***********************
     * Gate
     ***********************/
    const unsealBtn = document.getElementById("unseal");
    const passInput = document.getElementById("pass");
    const page = document.getElementById("page");
    const seal = document.getElementById("seal");

    function normalize(s){
      return (s||"").toString().trim().toUpperCase().replace(/\s+/g,"");
    }
    function failGate(){
      seal.classList.remove("shake");
      void seal.offsetWidth;
      seal.classList.add("shake");
      passInput.select();
    }
    function succeed(){
      page.classList.add("fadeOut");
      if (ctx){
        const now = ctx.currentTime;
        if (voiceGain){
          voiceGain.gain.cancelScheduledValues(now);
          voiceGain.gain.setValueAtTime(voiceGain.gain.value, now);
          voiceGain.gain.linearRampToValueAtTime(0.0001, now + 0.25);
        }
        if (ambGain){
          ambGain.gain.cancelScheduledValues(now);
          ambGain.gain.setValueAtTime(ambGain.gain.value, now);
          ambGain.gain.linearRampToValueAtTime(0.0001, now + 0.60);
        }
      }
      setTimeout(()=>{ window.location.href = NEXT_PAGE; }, 820);
    }
    function tryUnseal(){
      const expected = normalize(REQUIRED_SEQUENCE.join(""));
      const got = normalize(passInput.value);
      if (got === expected) succeed();
      else failGate();
    }

    unsealBtn.addEventListener("click", tryUnseal);
    passInput.addEventListener("keydown", (e)=>{ if (e.key === "Enter") tryUnseal(); });

    /***********************
     * Start fog reveal
     ***********************/
    function startRevealWithBestTiming(){
      if (voiceEl){
        voiceEl.addEventListener("loadedmetadata", ()=>{
          const dur = isFinite(voiceEl.duration) ? voiceEl.duration : 0;
          runFogReveal(dur ? (dur + 6) : 0);
        }, {once:true});
        setTimeout(()=> runFogReveal(0), 700);
      }else{
        runFogReveal(0);
      }
    }
    startRevealWithBestTiming();
  </script>
</body>
</html>
